<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaWeb06-Session]]></title>
    <url>%2F2019%2F07%2F19%2FJavaWeb06-Session%2F</url>
    <content type="text"><![CDATA[Session介绍和原理问题Request对象解决了一次请求内的不同Servlet之间的数据共享问题，那么一个用户的不同请求的处理需要使用相同的数据怎么办呢？ 解决Session。（HttpSession） 原理用户使用浏览器第一次向服务器发送请求，服务器在接收到请求后，调用对应的Servlet进行处理。在处理过程中会给用户创建一个Session对象，用来存储用户请求处理相关的公共数据，并将此Session对象的JSESSIONID以Cookie的形式存储在浏览器中（临时存储，浏览器关闭即时失效）。用户在发起第二次请求及后续请求时，请求信息会附带JSESSIONID，服务器进行处理时，会根据JSESSIONID返回对应的对象，这样就取到需要用的数据。每个用户的JSESSIONID是不同的，这样就可以识别发送请求的是哪一个具体的用户。 Session的特点和使用内部实现原理用户第一次访问服务器，服务器会创建一个session对象给此用户，并将给session对象的JSESSIONID使用Cookie技术存储到浏览器，保证用户的其他请求能够获取到同一个session对象，也保证了同一用户不同请求能够获取到共享的数据。 特点Session技术是依赖Cookie技术的服务端的存储技术。 ​ 注：​ Cookie：浏览器端的数据存储技术。​ Session：服务器端的数据存储技术。 由服务器完成创建。 Session依赖于Cookie技术。 以为Session创建好了，要一只伴随该用户的请求来使用的话，需要在每次请求都带着该用户的Session的唯一标识符（JSESSIONID）使用。 作用在一次会话中。（作用域） 每个用户独立拥有一个Session。 默认存储时间为30分钟。 作用解决了一个用户的不同请求的数据共享问题。 每个新产品或新技术的出现都是为了解决现有的痛点。 使用创建Session对象/获取Session对象： 1HttpSession session = request.getSession(); 如果请求中拥有Session的唯一标识符（JSESSIONID），则返回对应的Session对象； 如果请求中没有Session的唯一标识符（JSESSIONID），则创建新的Session对象并将其JSESSIONID作为Cookie数据存储到浏览器内存中（关闭浏览器JSESSIONID失效）。 设置Session存储时间 单个Session设置存储时间：session.setMaxInactiveInterval(int seconds); 服务器内所有项目的公共配置在Tomcat的路径下找到web.xml配置文件（路径：%TOMCAT_HOME%\conf\web.xml），使用文本编辑器打开，找到如下配置并进行更改： 1234&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt;&lt;!-- 注意单位为分钟 --&gt; 单个项目的配置在项目的web.xml配置文件中添加如下配置信息即可： 1234&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt;&lt;!-- 注意单位为分钟 --&gt; 注意： ​ 在有效存储时间内如果再次发起请求则会重新计算存储时间；​ 而在有效存储时间内未再次发起请求则该Session对象失效。 设置Session强制失效（即使Session还未失效，也要强制删除Session对象）： 使用场景举例：用户点击“登出\退出”的时候。 1session.invalidate(); 注意只要不关闭浏览器，并且Session不失效的情况下，同一个用户的任意请求在项目的任意Servlet中获取到的都是同一个Session对象。 作用域一次对话。 或者可以说：在JSESSIONID和Session对象不失效的情况下，它的作用域为整个项目。 重点用户什么时候能获取到Session？ 什么时候会获取到新的Session？ Session什么时候失效？ Session的数据流转和总结存储和获取数据1234// 存储session.setAttribute(String name, Object value);// 获取session.getAttribute(String name); // 返回的数据类型为Object 注意：存储的动作和取出的动作发生在不同请求中，但是存储要先于取出。 Session的使用时机一般用户在登录web项目时会将个人信息存储到Session中，供该用户的其他请求使用。 总结Session解决了一个用户在不同请求的数据共享问题，只要JSESSIONID不失效和Session对象不失效的情况下，用户的任意请求在处理时都能获取到同一个Session对象。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb05-Cookie]]></title>
    <url>%2F2019%2F01%2F17%2FJavaWeb05-Cookie%2F</url>
    <content type="text"><![CDATA[Cookie介绍及使用（创建和设置有效期）Cookie的作用解决了发送的不同请求之间的数据共享问题。 注意 Cookie不能存中文。要我Cookie封装在响应头和请求行里，HTTP响应头和请求行中不能有中文。 Cookie不安全。 一个Cookie对象存储一条数据，多条数据需要多创建几个Cookie对象进行存储。 使用Cookie的创建和存储 123456789// 创建Cookie对象Cookie cookie = new Cookie(String cookieName, String value);// 设置Cookiecookie.setMaxAge(int expiry); // 设置Cookie存储时间（注：expiry单位为秒）cookie.setPath(String uri); // 设置Cookir的请求路径// 响应Cookie对象给客户端response.addCookie(Cookie cookie); Cookie的获取 1234567// 获取Cookie信息数组Cookie[] cookies = response.getCookies();// 遍历Cookie信息数组（使用for循环遍历即可）for (Cookie ck : cookies) &#123; String name = ck.getName(); String value = ck.getValie();&#125; 特点 Cookie是浏览器端的数据存储技术； 存储的数据声明在服务器端； 临时存储：存储在浏览器的运行内存中，浏览器关闭即失效； 定时存储：设置了Cookie的有效期，存储在客户端的硬盘中，在有效期内，符合路径要求的都会附带该信息； 默认Cookie信息存储好之后，每次请求都会附带，除非设置请求路径。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb04-请求转发、重定向]]></title>
    <url>%2F2019%2F01%2F15%2FJavaWeb04-%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E3%80%81%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[请求乱码问题解决 使用String进行重新编码 1String name = new String(req.getParameter(“name”).toBytes(“iso8859-1”),”utf-8”); 使用公共配置 Get请求方式：第一步：在service()方法中使用req.setCharacterEncoding(“utf-8”);第二步：在tomcat服务器目录下的conf文件夹下找到server.xml文件，打开进行如下配置： 1&lt;Connector port=”8080” protocol=”HTTP/1.1” connectorTimeout=”20000” redirectPort=”8443” useBodyEncodingForURI=”true”/&gt; Post请求方式：在service()方法中使用request.setCharacterEncoding(“utf-8”); Servlet流程总结未加粗文本为不可见的，由Servlet容器或浏览器完成。 加粗文本为开发人员控制的，开发时需要关注的内容，Servlet的使用流程。 浏览器发起请求到服务器（请求）服务器接收浏览器的请求进行解析，创建request对象存储请求数据服务器调用对应的Servlet进行请求处理，并将request对象作为实参传递给Servlet的方法Servlet的方法执行进行请求处理 设置请求编码格式 设置响应编码格式 获取请求信息 处理请求信息 创建业务层对象 处理 调用业务层对象方法 响应处理结果 数据流程流程浏览器—-&gt;服务器—-&gt;数据库浏览器&lt;—-服务器&lt;—-数据库 请求转发问题服务器在接收到浏览器的请求后，仅仅使用一个Servlet进行请求处理，会造成不同的Servlet进行请求处理，会造成不同的Servlet逻辑代码冗余，Servlet的职责不明确。 解决使用请求转发。 特点 一次请求； 地址栏地址不改变。 作用实现多个Servlet联动操作处理请求，这样避免代码冗余，让Servlet的职责更加明确。 使用1req.getRequestDispatcher(“要转发的地址”).forward(req, response); 要转发的地址：相对路径。可以是Servlet的url-pattern地址，也可以是jsp文件位置。 注意请求转发后直接return即可。因为请求转发之后转发到的servlet进行处理之后已经对请求做出响应，做出请求转发操作的servlet再继续进行操作也没有意义了。 联想语句：多个Servlet联动处理同一个请求。 request对象的作用域问题假如第一个Servlet需要将处理结果或者处理建议给到第二个Servlet，使用请求转发后，不同Servlet之间怎么进行数据的共享呢？或者说数据怎么从一个Servlet流转到另一个Servlet呢？ 提醒：前一个Servlet将处理结果封装到request对象中，后一个Servlet将前一个Servlet封装的信息取出来并删除(看情况而定)，进行处理之后再进行同样的步骤转发给后面的Servlet（如果有）。 使用1234// 封装数据req.setAttribute(String name, Object obj);// 获取数据req.getAttribute(String name); 作用解决了一次请求内的不同Servlet的数据（请求数据+其他数据）共享问题。 作用域基于请求转发，一次请求中的所有Servlet共享。（或者说：一次请求内，请求所经历的所有servlet共享同一个request）。 注意使用request对象进行数据流转，数据只在一次请求内有效。 特点 Request由服务器创建 每次请求都会创建 生命周期：一次请求内 重定向问题 如果当前的请求，Servlet无法进行处理怎么办？ 如果使用请求转发，造成表单数据重复提交，怎么办？ 解决使用重定向。 使用123response.sendRedirect(“路径”);本地路径为：uri网络路径为：定向资源的URL信息 特点 两次请求 浏览器地址改变 避免表单重复提交 使用场景 如果请求中有表单数据，而数据又比较重要，不能重复提交，建议使用重定向。 如果请求被Servlet接收后，无法进行处理，建议使用重定向定位到可以处理的资源。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb03-Request对象和Response对象]]></title>
    <url>%2F2019%2F01%2F13%2FJavaWeb03-Request%E5%AF%B9%E8%B1%A1%E5%92%8CResponse%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Servlet的生命周期 从服务器启动后第一次调用到服务器关闭； 如果Servlet在web.xml中配置了load-on-startup，生命周期为服务器启动到服务器关闭。 从第一次调用，到服务器关闭。如果在web.xml中配置了load-on-startup则是从服务器启动到服务器关闭。 注意init()方法是对Servlet进行初始化的一个方法，会在Servlet第一次加载进入内存时执行。 destroy()方法是在Servlet被销毁时执行，也就是服务器关闭时。 service()方法、doGet()方法以及doPost()方法的使用和区别 service()：不管是get方式还是post方式，如果Servlet类中有service()方法，则优先调用service()方法。但是，不推荐重写service()方法。 doGet()：在没有service()方法的情况下，如果请求方式是get，则调用该处理请求的方法。 doPost()：在没有service()方法的情况下，如果请求方式是post，则调用该处理请求的方法。 注意如果在重写的service()方法中调用了父类的service()方法（super.service(arg0, arg1)），则service方法处理完后，会再次根据请求方式响应doGet()或doPost()方法执行。所以，一般情况下，我们是不在重写的service()方法中调用父类的service()方法的，避免出现405错误。 扩展：常见错误状态码404错误：资源未找到。 原因一：在请求地址中的Servlet别名书写错误。 原因二：虚拟项目名称拼写错误。 500错误：内部服务器错误 错误一：找不到web.xml中配置的url-pattern所映射的servlet类(配置错误，ClassNotFound) 解决：在web.xml中校验servlet类的全限定路径是否拼写错误。 错误二：因为处理请求的方法(service方法\doGet方法\doPost方法)中的代码执行错误导致。 解决：根据错误提示对处理请求的方法体中的代码进行错误排查并更改。 405错误：请求方式不支持 原因：请求方式和servlet中的方法不匹配所导致。解决： 使用service()方法进行请求处理(不推荐)，并不在service()方法中直接使用父类的service()方法 重写doGet()和doPost()方法，并准确根据请求方式进行所重写方法的代码编写 Request对象问题浏览器发起请求到服务器，会遵循HTTP协议将请求数据发送到服务器。那么服务器收到的请求该怎么存储呢？不但要存，而且要保证完整性。 解决使用对象存储，服务器每接收一个请求，就创建一个对象专门存储此次请求数据。 实现Request对象。 解释服务器在接收到浏览器的请求后，会创建一个request对象，对象中存储了此次请求相关的请求数据。服务器在调用Servlet时将创建的request对象作为实参传递给Servlet的方法，比如：service()方法。 作用request对象中封存了当前请求的所有请求信息。 使用获取请求头数据： 12345678// 获取请求方式request.getMethod();// 获取请求URLrequest.getRequestURL();// 获取请求URIrequest.getRequestURI();// 获取请求协议request.getScheme(); 获取请求行数据： 1234// 返回指定的请求头信息request.getHeader("键名");// 返回请求头的枚举集合request.getHeaderNames(); 获取用户数据（核心）： 123456// 获取指定的用户数据request.getParameter("键名");// 返回同键不同值的请求数据(多用于多选按钮)，返回的数组request.getParameterValues("键名");// 返回所有用户请求数据的枚举集合request.getParameterNames(); 注意 如果要获取的请求数据不存在，不会报错，会返回null。 request对象由tomcat服务器创建，并作为实际参数传递给处理请求的servlet的处理请求的方法。 Response对象作用一个用来将数据响应到浏览器的对象。 使用1234567// 设置响应头response.setHeader(String name,String value);// 在响应头中添加信息，但是同键会覆盖。response.addHeader(String name,String value);// 在响应头中添加响应信息，但是不会覆盖。// 设置响应状态response.sendError(int num, String msg);// 自定义响应状态码// 设置响应实体(核心)response.getWriter().write(String str);// 响应具体的数据给浏览器 设置响应编码格式1response.setContentType(“text/html;charset=utf-8”); 总结service()方法请求处理代码流程： 设置响应编码格式 获取请求数据 处理请求数据 数据库操作（MVC思想） 响应处理结果]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[经验分享]保证Cookie自动登录信息安全的方法]]></title>
    <url>%2F2019%2F01%2F12%2F%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB-%E4%BF%9D%E8%AF%81Cookie%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[方法一 将用户的认证信息保存在一个Cookie中。 cookie名：uid。推荐进行加密，比如MD5(‘站点名称’)等。 cookie值：登录名|有效时间|Expires|hash值。hash值可以由“登录名+有效时间Expires+用户密码(进行加密处理后的)的前几位+salt”，salt是保证在服务器端站点配置文件中的随机数。 该设计的缺点 即使数据库被盗了，盗用者还是无法登录到系统，因为组成cookie值的salt是保证在服务器站点配置文件中而非数据库中。 如果账号被盗了，用户修改密码，可以使盗用者的cookie值无效。 如果服务器端的数据库被盗了，通过修改salt值可以使所有用户的cookie值无效，迫使用户重新登录系统。 有效时间Expires可以设置为当前时间+过去时间（比如两天），这样可以保证每次登录的cookie值都不一样，防止盗用者窥探到自己的cookie值后作为后门，长期登录。 方法二每个用户登录之后生成一个随机的GUID，然后把GUID存在数据库里面（也可以考虑使用Redis，把用户信息和随机GUID以KEY-VALUE方式存储GUID-用户信息，存储时设置超时时间，比如20分钟，每次验证用户信息都自动延长20分钟。如果用户选择记住登录，则设置时间为30天）。安全要求高的话，每次重新登录（包括用户名密码和使用GUID）都重新生成GUID，旧的作废，这样在新的地方登录之后旧的记住登录就自动失效。安全要求低的话可以每次都返回相同的，直到用户修改密码之后让旧的GUID作废。用户Cookies里面没有直接和用户名、密码有关的内容，即使Cookies被盗了也无法修改密码，原用户发现账号异常之后只要修改密码就可以防止盗号了。 另：防止XSS攻击，可以将Http-Only设置为True。]]></content>
      <categories>
        <category>实战经验</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb02-Servlet的url-pattern匹配规则]]></title>
    <url>%2F2019%2F01%2F11%2FJavaWeb02-Servlet%E7%9A%84url-pattern%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[几种容易混淆的规则 servlet容器中的匹配规则既不是简单的通配，也不是正则表达式，而是特定的规则。所以不要用通配符或者正则表达式的匹配规则来看到servlet的url-pattern； Servlet 2.5开始，一个servlet可以使用多个url-pattern规则，&lt;servlet-mapping&gt;标签表明了与该servlet响应的匹配规则，每个&lt;url-pattern&amp;gt代表一个匹配规则； 当servlet容器接收到浏览器发起的一个url请求后，容器会用url减去当前应用的上下文路径，以剩下的字符串作为servlet映射，假如url是http://localhost:8080/demo/index.html，其应用上下文是demo，容器http://localhost:8080/demo去掉，用剩下的/index部分拿来做servlet映射匹配； url-pattern映射匹配过程是有优先顺序的，而且，当有一个servlet匹配成功以后，就不会继续往后去匹配后面的servlet了。 一、四种匹配规则精准匹配&lt;url-pattern&gt;中配置的项必须与url完全精准匹配。 123456&lt;servlet-mapping&gt; &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/user/users.html&lt;/url-pattern&gt; &lt;url-pattern&gt;/index.html&lt;/url-pattern&gt; &lt;url-pattern&gt;/user/addUser.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 当在浏览器中输入如下几种url时，都会被匹配到该servlet 123http://localhost:8080/demo/user/user.htmlhttp://localhost:8080/demo/index.htmlhttp://localhost:8080/demo/user/addUser.action 注意：http://localhost:8080/demo/user/addUser/是非法url，不会被当作http://localhost:8080/demo/user/addUser识别 另外，上述url后面可以跟任意的查询条件，都会被匹配，如http://localhost:8080/demo/user/addUser?username=jerry&amp;age=18会被匹配到MyServlet。 路径匹配以”/”字符开头，并以”/*”结尾的字符串用于路径匹配1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/user/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 路径以/user/开始，后面的路径可以任意。比如下面的url都会被匹配： 123http://localhost:8080/demo/user/user.htmlhttp://localhost:8080/demo/user/addUser.actionhttp://localhost:8080/demo/user/updateUser.action 扩展名匹配以”*.”开头的字符串被用于扩展名匹配 12345&lt;servlet-mapping&gt; &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 以上，则任何扩展名为jsp或action的url请求都会匹配，比如下面的url都会被匹配： 12http://localhost:8080/demo/user/users.jsphttp://localhost:8080/demo/toHome.action 缺省匹配1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 二、匹配顺序精准匹配1234servlet-mapping1：&lt;url-pattern&gt;/user/users.html&lt;/url-pattern&gt;servlet-mapping2：&lt;url-pattern&gt;/*&lt;/url-pattern&gt; 当一个请求http://localhost:8080/demo/user/users.hml来的时候，servlet-mapping1匹配到之后不再用servlet-mapping2匹配。 路径匹配先最长路径匹配，再最短路径匹配 1234servlet-mapping1：&lt;url-pattern&gt;/user/*&lt;/url-pattern&gt;servlet-mapping2：&lt;url-pattern&gt;/*&lt;/url-pattern&gt; 当一个请求http://localhost:8080来的时候，servlet-mapping1匹配到之后，不在用servlet-mapping2匹配。 扩展匹配1234servlet-mapping1：&lt;url-pattern&gt;/user/*&lt;/url-pattern&gt;servlet-mapping2：&lt;url-pattern&gt;*.action&lt;/url-pattern&gt; 当一个请求http://localhost:8080/demo/user/addUser.action来的时候，servlet-mapping1匹配到，不再用servlet-mapping2匹配。 缺省匹配以上都找不到servlet，就用默认的servlet，配置为： 1&lt;url-pattern&gt;/&lt;/url-pattern&gt; 三、需要注意的问题路径匹配和扩展名匹配无法同时设置匹配方法只有三种，要么是路径匹配(以”/”字符开头，并以”*”结尾)，要么是扩展名匹配(以”*.”开头)，要么是精确匹配，三种匹配方法不能进行组合，不要想当然使用通配符或正则表达式规则。 如&lt;url-pattern&gt;/user/*.action&lt;/url-pattern&gt;是非法的 另外注意：&lt;url-pattern&gt;/aa/*/bb&lt;/url-pattern&gt;是精准匹配，合法，这里的*不是通配的含义 “/”和”/*”含义不相同 “/*”属于路径匹配，并且可以匹配所有request，由于路径匹配的优先级仅次于精准匹配，所以”/*”会覆盖所有的扩展名匹配，很多404错误均由此引起，所以这是一个特别恶劣的匹配模式，一般只用于filter的url-pattern “/”是servlet中特殊的匹配模式，且该模式有且仅有一个实例，优先级最低，不会覆盖其他任何url-pattern，只是会替换servlet容器的内建default servlet，该模式同样会匹配所有request。 配置”/”后，一种可能的现象是MyServlet会拦截诸如http://localhost:8080/demo/user/addUser.action、http://localhost:8080/demo/user/updateUser的格式的请求，但是并不会拦截http://localhost:8080/demo/user/users.jsp、http://localhost:8080/demo/index.jsp，这是因为servlet容器有内置的”*.jsp”匹配器，而扩展名匹配的优先级高于缺省匹配，所以才会有上述现象。 Tomcat在%CATALINA_HOME%\conf\web.xml文件中配置了默认的servlet，配置代码如下 123456789101112131415161718192021222324252627282930313233343536&lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;fork&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;xpoweredBy&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;3&lt;/load-on-startup&gt; &lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!-- The mappings for the JSP servlet --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 参考文献：http://stackoverflow.com/questions/4140448/difference-between-and-in-servlet-mapping-url-pattern “/”和”/*”均会拦截静态资源的加载，需要特别注意 举例]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Web</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb01-Servlet入门]]></title>
    <url>%2F2019%2F01%2F11%2FJavaWeb01-Servlet%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Servlet概述和介绍概念狭义的Servlet是指Java语言实现的一个接口。广义的Servlet是指任何实现了Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类似的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。 只要是实现了Servlet接口的类都可以称之为Servlet。 Servlet类需要继承HttpServlet，HttpServlet类又继承了GenericServlet类，而GenericServlet类实现了Servlet接口。 特点： 运行在支持Java的应用服务器上； Servlet的实现遵循了服务器能识别的规则，也就是服务器会自动根据请求调用对应的Servlet； 进行请求处理； 简单方便，可移植性强。 Servlet的访问流程运行流程12345URL：http://localhost:8080/myservlet/my组成：服务器地址:端口号/虚拟项目名/servlet的别名注： 虚拟项目：webapps下的文件夹的名称 servlet的别名：在web.xml设置的servlet-name对应的servlet-mapping下的url-pattern 浏览器发送请求到服务器，服务器根据请求URL地址中的URI信息，在Tomcat的webapps目录下找到对应的项目文件夹，然后在web.xml 中检索对应的servlet，找到后调用并执行Servlet。 URI：虚拟项目名/servlet的别名。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Web</tag>
      </tags>
  </entry>
</search>
