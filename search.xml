<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[玩好Spring]Spring的IoC原理]]></title>
    <url>%2F2019%2F03%2F04%2F%E7%8E%A9%E5%A5%BDSpring-Spring%E7%9A%84IoC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[IoC（Invesion of Control，控制反转）也称依赖注入（Dependency Injection），作为Spring的一个核心思想，是一种设计对象之间依赖关系的原则及其相关技术，作为Spring的一个关键技术，让我们好好了解一下。 IoC是什么？高内聚低耦合可以说是软件技术形态的终极目标。用学术界的话来说，软件的两个本质特征就是构造性和演化性，高内聚低耦合的设计能够让构造和演化都更加高效，比如： 开发更方便组织分工 代码更容易进行复用 更容易进行测试 软件演化有更好的灵活性，能快速响应需求变化，维护代价更小 软件设计各种技术的出现，无一不是朝着这个终极目标努力的。面向对象、基于组件（学术界称为构件）的软件开发、面向切面编程（AOP）、Java近些年六星的模块化方法（比如OSGi技术）等等，这些方法和技术的出现，无外乎都是为了让软件更加高内聚低耦合。与此同时，各路大神还提出软件设计原则和模式，来规范我们的软件形态。我们今天谈 IoC也是其中的一个大招。IoC（Inversion of Control，控制反转）也称为依赖注入（Dependency Injection），作为Spring的一个核心思想，是一种设计对象之间依赖关系的原则及其相关技术。 先来看看字面上怎么解释：当一个对象创建时，它所依赖的对象由外部传递给它，而非自己取创建所依赖的对象（比如通过new操作）。因此，也可以说在对象如何获取它的依赖对象这件事情上，控制权反转了。这便不难理解控制反转和依赖注入这两个名字的由来了。 场景举例上面的解释听起来还是晦涩，让我们直接看具体的例子，上代码！ 有个土豪老板，我们经常要出差，因此经常要订机票。订机票可以通过去哪儿网订票，也可以是通过携程订票。 我们马上可以想到通过三个类来表达这个场景，Boss，QunarBookingService，CtripBookService。当然了，我们还应该提供一个BookingService接口，作为QunarBookingService和CtripBookingService的公共抽象。面向接口编程是面向对象设计的基本原则，如果这都不了解，感觉取看看设计模式相关资料，推荐《Head First 设计模式》。 BookingService.java 123456package cn.imwarhorse.iocdemo;public interface BookingService() &#123; // 预定航班 void bookFlight();&#125; QunarBookingService.java 12345678package cn.imwarhorse.iocdemo;public class QunarBookingService implements BookingService &#123; @Override public void bookFlight() &#123; System.out.println("book fight by Qunar!"); &#125;&#125; CtripBookingService.java 12345678package cn.imwarhorse.iocdemo;public class CtripBookingService implements BookingService &#123; @Override public void bookFlight() &#123; System.out.println("book flight by Ctrip!"); &#125;&#125; 好了，土豪老板出门谈生意，得订机票了，Boss就琢磨着怎么订票呢？Boss比较了一下价格，这一次决定去哪儿，对应的Boss的代码： Boss.java 123456789101112131415161718192021package cn.imwarhorse.iocdemo;public class Boss &#123; private BookingService bookingService; public Boss() &#123; this.bookingService = new QunarBookingService(); &#125; public BookingService getBookingService() &#123; return bookingService; &#125; public void setBookingService(BookingService bookingService) &#123; this.bookingService = bookingService; &#125; public void goSomewhere() &#123; bookingService.bookFlight(); &#125;&#125; 在Boss的构造方法中，将其bookingService成员变量实例化为QunarBookingService，goSomewhere()方法中就可以调用bookingService的bookFlight方法了。 为了这个场景Run起来，我们还需要一个main方法： App.java 123456789101112package cn.imwarhorse.iocdemo;public class App &#123; public static void main(String[] args) &#123; bossGoSomewhere(); &#125; statis void bossGoSomewhere() &#123; Boss boss = new Boss(); boss.goSomewhere(); &#125;&#125; 运行之后可以看到程序在Console中打印出了”book flight by Qunar!”。 使用IoC的场景在这个例子中，我们看到Boss需要使用BookingService，于是Boss自己实例化了一个QunarBookingService对象。挠一下你头发还算较多的脑阔想想，身为土豪Boss，思考的都是公司战略的事儿，订个票还要自己选择通过什么方式来完成，这个Boss是不是当得实在太苦逼了。 所以土豪感觉给自己找了个美女秘书（没有深层次的意思），Boss要出差时，只需要说一声他需要订票服务，至于是哪个服务，让美女秘书选好后告诉他即可（注入！！）。（我知道事实是只需要把票给Boss就行，别杠！） 这样的话，Boss是不是一身轻松了？而这个美女秘书还是免费包邮的，这正是Spring扮演的角色。来看看使用Spring之后的代码。 我们在pom.xml文件中加入依赖（项目使用Maven作为构建工具，我过几天会有上传相关博文，如果等不及的话现在赶紧去找Maven的相关资料康康）： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.1.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; QunarBookingService.java 1234567891011package cn.imwarhorse.iocdemo;import org.springframework.stereotype.Component;@Componentpublic class QunarBookingService implements BookingService &#123; @Override public void bookFlight() &#123; System.out.println("book fight by Qunar!") &#125;&#125; 这里我们使用Spring的@Component注解将QunarBookingService注册进Spring的Context，这样它就可以被注入到需要它的地方。相应的，创建QunarBookingService实例化的责任也交给了Spring。所谓的美女秘书帮你搞定！ 注解相关知识点后面进行补充。 新建一个SmartBoss类，聪明的老板知道把选择订机票服务这样的杂事交给秘书来做。 SmartBoss.java 12345678910111213141516171819202122package cn.imwarhorse.iocdemo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class SmartBoss &#123; private BookingService bookingService; @Autowired public void setBookingService(BookingService bookingService) &#123; this.bookingService = bookingService; &#125; public BookingService getBookingService() &#123; return bookingService; &#125; public void goSomewhere() &#123; bookingService.bookFlight(); &#125;&#125; 在上面的代码中，SmartBoss不再自己创建BookingService的实例，只是通过@Autowired注解来告诉Spring秘书我需要一个BookingService。 调用代码因此也要做一些小修改，需要创建Spring的Context： 12345678910static void smartBossGoSomewhere() &#123; AbstractApplicationContext context = new AnnotationConfigApplicationContext(App.class); try &#123; SmartBoss boss = context.getBean(SmartBoss.class); boss.goSomewhere(); &#125; finally &#123; context.close(); &#125;&#125; IoC的好处回到正题，通过上面的例子，我们来看看IoC到底带来了哪些好处？ Boss没有和某个具体的BookingService类耦合到一起了，这样Boss的维护和演化就更加方便。想象一下，如果Boss需要改用CtripBookingService，这时需要修改Boss.java的代码，更换接口的实现非常方便，给Boss注入新的实现即可，轻松惬意。（当然，要做到热插拔还需要进一步的工作，要么得玩转类加载器这玩意，或者借助OSGi这样的神器）。这也是典型的开放-封闭原则的例子。即对现有模块，功能扩展应该是开放的，而对其代码修改应该是封闭的，即能够做到不需要修改已有代码来扩展新的功能。 想象一下，如果Boss自己直接去实例化QunarBookingService，而QunarBookingService在另外一个Package中甚至另一个Jar包中，你可得import进来才能使用，耦合度max！现在好了，Boss只依赖于抽象接口，测试更方便了，Mock一下就轻松搞定！Boss和QunarBookingService彼此不知道对方，Spring帮两者粘合在一起。 为什么IoC是个大招，因为它会自然而然得促进你应用一些好的设计原则，会帮助你开发出更加“高内聚低耦合”的应用。 IoC如何实现最后我们简单说说IoC是如何实现的。想象一下，如果我们自己来实现这个依赖注入的功能，我们怎么来做？无外乎： 读取标注或者配置文件，看看Boss依赖的是哪个BookingService，拿到类名 使用反射的API，基于类名实例化对应的对象实例 将对象实例，通过构造函数或者setter，传递给Boss 我们发现其实自己来实现也不是很难，Spring实际也就是这么做的。这么看的话其实IoC就是一个工厂模式的升级版。当然要做一个成熟的IoC框架，还是非常多细致的工作要做，Spring不仅提供了一个已经成为业界标准的Java IoC框架，还提供了更多强大的功能，所以大家就别去造轮子了（当技术到达了更高的境界之后，可以尝试着造轮子）。希望了解IoC更多实现细节不妨通过同学Spring的源码来加深理解！ David https://www.tianmaying.com/tutorial/spring-ioc]]></content>
      <categories>
        <category>玩好Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[玩好Spring]初识Spring]]></title>
    <url>%2F2019%2F03%2F02%2F%E7%8E%A9%E5%A5%BDSpring-%E5%88%9D%E8%AF%86Spring%2F</url>
    <content type="text"><![CDATA[前言 每个新产品或新技术的出现都是为了解决现有的问题或痛点 而框架伴随它们的问世的同时也承载着“神圣的使命”。 回想在还没有接触框架的时候，代码是怎么写的。不停的newnewnew…，整个程序的多个分层之间，依赖性很强，A层用到了B层的类，B层用到了C层的类，C层用了B层的类……这是框架解决的痛点之一——高耦合，不易扩展。 基于上一条，各层级之间有千丝万缕的关联，而此时，项目需求变更，其中一层的某个或某些类中的代码需要发生变动，或者整个项目的架构需要发生变动，此时工作量是相当大的。这是框架解决的痛点之二——需求变更导致工作量指数性增加。 重复造轮子是愚蠢的。这是框架解决的痛点之三——代码重用率高，重复造轮子难以专注于业务。 技术演变过程在2015年（或者说2014年）之前，企业级应用技术选型上Strust大行其道，但在2014年到2015年间，“轻量级”这个概念进入开发人员的视野中，Spring这样的轻量级框架也就自然而然的接管的“大好江山”，当然，促使开发人员放弃Struts这个“行动不便的老家伙”的最主要原因是那两年Struts频繁被曝出高危漏洞，导致开发人员和企业对它的信心逐渐消失，实在难顶… Spring是什么Spring是一个轻量级的DI/IoC（控制反转）和AOP（面向切面）的容器框架。 Spring的两大核心：第一个是DI也叫IoC，可以简单的认为就是一个东西，中文意思依赖注入/控制反转；第二个是AOP，即面向切面。 参考资料：[Spring Framework-Wiki][https://zh.wikipedia.org/wiki/Spring_Framework][Spring框架-百度百科][https://baike.baidu.com/item/spring%E6%A1%86%E6%9E%B6/2853288] Spring的优点 易于使用。内部隐藏了大部分复杂的实现，而且，如果难用那还用框架干嘛，闲得蛋疼…？ 使用Spring的IoC容器，将对象之间的依赖关系交给Spring，降低组件之间的耦合性，让我们更专注于业务逻辑； 可以提供众多的服务，事务管理等； 良好的AOP支持，方便面向切面编程； 对主流的框架提供了很好的继承支持，比如Hibernate，Strusts2，JPA等（前两个现在来说不算主流了）； Spring DI机制降低了业务对象替换的替换的复杂性； 对代码低侵入，代码污染极低； 高度可开放性，并不强制依赖于Spring，开发者可以自由选择Spring 部分或全部。]]></content>
      <categories>
        <category>玩好Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb13-JSP的九大内置对象及四个作用域对象]]></title>
    <url>%2F2019%2F02%2F22%2FJavaWeb13-JSP%E7%9A%84%E4%B9%9D%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%9B%9B%E4%B8%AA%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[九大内置对象内置对象JSP文件在转译成其对应的Servlet文件的时候自动生成并声明的对象。我们在JSP页面中直接使用即可。 注意内置对象在JSP页面中使用，只能在局部代码块或者脚本段语句中使用，不能在全局代码块中使用。 因为JSP文件转译后所有的代码都在转译后的Servlet的service()方法下，而九大内置对象都声明在service()方法中，全局代码块无法访问。 pageContext对象 页面上下文对象，封存了其他内置对象。封存了当前jsp的运行信息。 注意每个JSP文件单独拥有一个pageContext对象。 作用域当前页面。 request对象 封存当前请求信息数据的对象。由Tomcat服务器创建。 作用域一次请求中。 Session对象 此对象是用来存储用户的不同请求的共享数据的。 作用域一次会话中。 application 此对象用来存储用户的不同请求的共享数据的。一个项目只有一个，存储所有用户共享数据的对象，以及完成其他操作（比如获取文件的绝对路径）。 作用域整个项目内。 response对象 用来响应请求处理结果给浏览器的对象。设置响应头，重定向。 out对象 响应对象，JSP内部使用，带有缓冲区的响应对象，效率高于response对象。 page对象 代表当前JSP的对象。相当于Java中的this。 exception对象 异常对象，存储了当前运行的异常信息。 注意：使用此对象需要在page指令中使用属性isErrorPage=”true”开启。 config对象 也就是ServletConfig，只要是用来获取web.xml中的配置数据，完成一些初始化数据的读取。 四个作用域pageContext作用域 当前页面。解决了当前页面内的数据共享问题。获取其他内置对象。 request作用域 一次请求。一个请求的Servlet的数据共享。通过请求转发将数据流转给下一个Servlet。 session作用域 一次会话。一个用户的不同请求的数据共享。将数据从一次请求流转给其他请求。 application作用域 项目内。不同用户的数据共享问题。将数据从一个用户的数据流转给其他用户。 作用数据流转。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb12-JSP的静/动态引入及forward转发标签]]></title>
    <url>%2F2019%2F02%2F21%2FJavaWeb12-JSP%E7%9A%84%E9%9D%99-%E5%8A%A8%E6%80%81%E5%BC%95%E5%85%A5%E5%8F%8Aforward%E8%BD%AC%E5%8F%91%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[静态引入使用1&lt;%@include file="要引入的jsp文件的相对路径" %&gt; 特点 会将引入的jsp文件和当前jsp文件转译成一个Java（Servlet）文件使用； 在网页中也就显示处了合并后的显示效果。 注意静态引入的jsp文件不会单独转译成Java（Servlet）文件。 当前文件和静态引入的jsp文件不能够使用Java代码声明同名变量。 动态引入使用1&lt;jsp:include page="要引入的jsp文件的相对路径"&gt;&lt;/jsp:include&gt; 特点 会将引入的jsp文件单独编译，在当前文件编译好的Java文件中调用引入的jsp文件的编译文件。 在网页中显示合并后的显示效果。 注意动态引入允许文件中声明同名变量。 静态引入和动态引入的优点：降低jsp代码的冗余，便于维护升级。 forward转发标签使用1&lt;jsp:forward page="要转发的jsp文件的相对路径"&gt;&lt;/jsp:forward&gt; 特点 一次请求； 地址栏信息不改变。 注意在转发标签的闭合标签中间除了写&lt;jsp:param value=”” name=”” /&gt;不会报错，其他的任意字符都会报错，包括空格。 name属性为附带的数据的键名。 value为附带的数据内容。 转发时会将数据以?的形式拼接在转发路径的后面。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb11-JSP之代码块]]></title>
    <url>%2F2019%2F02%2F21%2FJavaWeb11-JSP%E4%B9%8B%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[局部代码块特点局部代码块中声明的Java代码会被原样转译到jsp对应的Servlet文件的_JspService()方法中。 代码块中声明的变量都是局部变量。 使用1&lt;% Java代码 %&gt; 缺点使用局部代码块在jsp中进行逻辑判断，书写麻烦，阅读困难。 使用时机尽量少在jsp中加入逻辑代码。 开发中，Servler进行请求逻辑处理，使用jsp进行页面展现。 全局代码块特点声明的Java代码作为全局代码转译到对应的Servlet类中。 使用1&lt;%! 全局代码 %&gt; 注意全局代码块声明的代码，需要使用局部代码块调用。 脚本段语句特点帮助我们快速的获取变量和方法的返回值响应给浏览器。 使用1&lt;%= 变量名或方法 %&gt; 注意不要再变量名或方法后使用分号。 位置除了JSP语法要求以外的任何位置都可以写。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb10-JSP之page指令]]></title>
    <url>%2F2019%2F02%2F21%2FJavaWeb10-JSP%E4%B9%8Bpage%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[JSP的注释前端语言注释会被转译，也会被发送，但是不会被浏览器执行。 1&lt;!-- --&gt; Java语言注释会被转译，但是不会被Servlet执行。 123// /**//***/ JSP注释不会被转译。 1&lt;%-- --%&gt; page指令1&lt;% page 属性名="属性值" 属性名="属性值"...%&gt; 属性 language：声明JSP被转译的语言。通常是值为java。 import：声明转译的java文件要导入的包，不同的包使用英文逗号隔开。 pageEncoding：设置JSP文件的数据编码格式。 contentType：设置JSP数据响应给浏览器时，浏览器的解析和编码格式。举例：”text/html;charset=utf-8”。 session：设置转译的Servlet中是否开启Session支持，默认开启。true表示开启，false表示关闭。 errorPage：设置JSP运行错误后跳转的页面。 extends：设置JSP转译的Java文件要继承的父类。 作用page指令的作用就是配置jsp文件的转译相关的参数。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb09-JSP的概念和运行原理]]></title>
    <url>%2F2019%2F02%2F21%2FJavaWeb09-JSP%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[问题在学了Servlet之后，使用Servlet进行页面的展现，代码书写过于麻烦。极大的影响了开发的效率，那么有没有一种方式可以让我们像以前写网页一样来进行网页的编程工作呢？ 解决使用JSP技术。 概念（了解）JSP全名为Java Server Page，中文名叫Java服务器页面，其根本是一个简化的Servlet设计，它是由Sun Microsystems公司提倡、许多公司参与的一起建立的一种动态网页技术标准。 在保留Servlet的优点的同时，可以让我们像以前编写HTML一样流畅的编写网页信息。也就是说，用JSP来进行网页信息的响应的话，它里面可以进行业务逻辑判断（不可取）。 特点 本质上还是Servlet（内部由JspServlet将JSP转义为Servlet）； 跨平台，一次编写到处运行； 组件跨平台； 健壮性和安全性。 JSP的访问原理浏览器发起请求，请求JSP，请求被Tomcat服务器接收，执行JspServlet，将请求的JSP文件转义成为对应的Java文件（也是Servlet），然后执行转义好的Java文件。 JSP的语法和指令 JSP的page指令 JSP的taglib指令 JSP的局部代码块 JSP的全局代码块 JSP的脚本段 JSP的注释 JSP的静态引入（JSP的include指令） JSP的动态引入 页面转发（forward标签） JSP的内置对象 PageContext对象 Request对象 Session对象 Application对象 Response对象 Out对象 Page对象 Exception对象 是否为动态网页的衡量标准：页面内数据数据是否会动态的更改。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb08-web.xml与server.xml]]></title>
    <url>%2F2019%2F02%2F20%2FJavaWeb08-web-xml%E4%B8%8Eserver-xml%2F</url>
    <content type="text"><![CDATA[web.xml作用存储项目相关的配置信息，保护Servlet。解耦一些数据和对程序的依赖。 使用位置每个Web项目中。 Tomcat服务器中（在服务器目录conf目录中）。 区别Web项目下的web.xml文件为局部配置，针对本项目的配置。 Tomcat下的web.xml文件为全局配置，配置作用域服务器下的所有Web项目，但是，优先级小于局部配置。 内容（核心组件） 全局上下文配置（全局配置参数）； Servlet配置； 过滤器配置； 监听器配置。 加载顺序Web容器会按ServletContext –&gt; context-param –&gt; listener –&gt; filter –&gt; servlet这个顺序加载组件，这些元素可配置在web.xml中。 加载时机服务器启动时。 server.xml问题浏览器发起请求后，服务器根据请求在webapps目录下调用对应的Servlet进行请求处理。那么为什么是webapps目录暗道不能是其他的目录吗？ 解决了解server.xml文件的配置信息。 内容(核心组件)1234567891011&lt;Server&gt; &lt;Service&gt; &lt;Connector /&gt; &lt;Connector /&gt; &lt;Engine&gt; &lt;Host&gt; &lt;Context /&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;Server&gt; 热部署把下面这段配置复制到server.xml的&lt;Host&gt;组件中就能实现热部署： 1&lt;Context path="/项目别名" reloadable="false" docBase="需要进行热部署的项目的绝对路径，路径要到WebRoot" /&gt; 如果把reloadable更改为true，则每次Servlet发生改变，项目都会重新加载到内存。 注意：如果进行了热部署的项目要删除，一定要把在server.xml文件中配置的热部署&lt;Context&gt;删除，否则Tomcat在启动时会报错。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb07-ServletContext及ServletConfig对象]]></title>
    <url>%2F2019%2F02%2F20%2FJavaWeb07-ServletContext%E5%8F%8AServletConfig%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[ServletContext对象问题Request解决了一次请求内的数据共享问题，Session解决了用户不同请求间的数据共享问题，那么不同数据的数据共享该怎么办呢？ 解决ServletContext对象。 每次写“解决”这一项的时候总感觉自己在说废话…… 作用解决不同用户间的数据共享问题。 原理ServletContext对象由服务器进行创建，一个项目只有一个ServletContext对象。不管在项目的任意位置进行获取得到的都是同一个ServletContext对象，那么不同用户发起的请求获取到的也就是同一个对象了，该对象由所有用户共同拥有。 特点由服务器创建； 用户共享； 一个项目只有一个。 生命周期服务器启动到服务器关闭 作用域整个项目内 使用获取ServletContext对象： 123456// 第一种（常用）ServletContext context = this.getServletContext();// 第二种（特殊情况下使用）ServletContext context = this.getServletConfig.getServletContext();// 第三种（常用）ServletContext context = request.getSession().getServletContext(); 使用ServletContext对象完成数据共享： 1234// 数据存储context.setAttribute(String name, Object value);// 数据获取context.getAttribute(String name); 注意：不同的用户可以给ServletContext对象进行数据存取。 获取项目中web.xml文件中的全局配置数据： 12345// 根据键的名字返回web.xml中适配的全局数据的值，返回String类型。如果不存在则返回null。context.getInitParameter(String name);// 返回键名的枚举context.getInitParameterNames(); web.xml中配置全局数据的方式（适用于所有XML）： 1234&lt;context-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;Edward&lt;/param-value&gt;&lt;/context-param&gt; 注意：一组&lt;context-param&gt;标签只能存储一组键值对数据，多组可以声明多个&lt;context-param&gt;进行存储。 作用：将静态数据和代码进行解耦。 获取项目WebRoot下的资源的绝对路径： 12// 获取的路径为项目根路径，path参数为项目根目录下的路径。String path = context.getRealPath(String path); 获取WebRoot下的资源的流对象： 1InputStream is = context.getResourceAsStream(String path); 注意：此种方式只能获取项目根目录下的资源流对象，class文件的流对象需要使用类加载器获取。 path参数为项目根目录下的路径。 ServletConfig对象问题在使用ServletContext对象获取web.xml中的全局配置文件，在web.xml中，每个Servlet也可以进行单独的配置，那么该怎么获取配置信息？ 解决使用ServletConfig对象。 作用ServletConfig对象是Servlet的专属配置对象，每个Servlet都单独拥有一个ServletConfig对象，用来获取web.xml中的配置信息。 使用获取ServletConfig对象： 1ServletConfig config = this.getServletConfig(); 获取web.xml中Servlet的配置信息： 1config.getInitParameter(String name); 在web.xml中配置数据的方式： 12345678&lt;servlet&gt; &lt;servlet-name&gt;ServletConfigServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.text.servlet.ServletConfigServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;config&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; 小结Request：解决了一次请求内的数据共享问题。 Response：一个用来将数据响应到浏览器的对象。 Cookie：解决了发送的不同请求之间的数据共享问题。浏览器端存储技术。 Session：解决了一个用户的不同请求的数据共享问题。服务器端存储技术。依赖于Cookie。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb06-Session]]></title>
    <url>%2F2019%2F01%2F19%2FJavaWeb06-Session%2F</url>
    <content type="text"><![CDATA[Session介绍和原理问题Request对象解决了一次请求内的不同Servlet之间的数据共享问题，那么一个用户的不同请求的处理需要使用相同的数据怎么办呢？ 解决Session。（HttpSession） 原理用户使用浏览器第一次向服务器发送请求，服务器在接收到请求后，调用对应的Servlet进行处理。在处理过程中会给用户创建一个Session对象，用来存储用户请求处理相关的公共数据，并将此Session对象的JSESSIONID以Cookie的形式存储在浏览器中（临时存储，浏览器关闭即时失效）。用户在发起第二次请求及后续请求时，请求信息会附带JSESSIONID，服务器进行处理时，会根据JSESSIONID返回对应的对象，这样就取到需要用的数据。每个用户的JSESSIONID是不同的，这样就可以识别发送请求的是哪一个具体的用户。 Session的特点和使用内部实现原理用户第一次访问服务器，服务器会创建一个session对象给此用户，并将给session对象的JSESSIONID使用Cookie技术存储到浏览器，保证用户的其他请求能够获取到同一个session对象，也保证了同一用户不同请求能够获取到共享的数据。 特点Session技术是依赖Cookie技术的服务端的存储技术。 ​ 注：​ Cookie：浏览器端的数据存储技术。​ Session：服务器端的数据存储技术。 由服务器完成创建。 Session依赖于Cookie技术。 以为Session创建好了，要一只伴随该用户的请求来使用的话，需要在每次请求都带着该用户的Session的唯一标识符（JSESSIONID）使用。 作用在一次会话中。（作用域） 每个用户独立拥有一个Session。 默认存储时间为30分钟。 作用解决了一个用户的不同请求的数据共享问题。 每个新产品或新技术的出现都是为了解决现有的痛点。 使用创建Session对象/获取Session对象： 1HttpSession session = request.getSession(); 如果请求中拥有Session的唯一标识符（JSESSIONID），则返回对应的Session对象； 如果请求中没有Session的唯一标识符（JSESSIONID），则创建新的Session对象并将其JSESSIONID作为Cookie数据存储到浏览器内存中（关闭浏览器JSESSIONID失效）。 设置Session存储时间 单个Session设置存储时间：session.setMaxInactiveInterval(int seconds); 服务器内所有项目的公共配置在Tomcat的路径下找到web.xml配置文件（路径：%TOMCAT_HOME%\conf\web.xml），使用文本编辑器打开，找到如下配置并进行更改： 1234&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt;&lt;!-- 注意单位为分钟 --&gt; 单个项目的配置在项目的web.xml配置文件中添加如下配置信息即可： 1234&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt;&lt;!-- 注意单位为分钟 --&gt; 注意： ​ 在有效存储时间内如果再次发起请求则会重新计算存储时间；​ 而在有效存储时间内未再次发起请求则该Session对象失效。 设置Session强制失效（即使Session还未失效，也要强制删除Session对象）： 使用场景举例：用户点击“登出\退出”的时候。 1session.invalidate(); 注意只要不关闭浏览器，并且Session不失效的情况下，同一个用户的任意请求在项目的任意Servlet中获取到的都是同一个Session对象。 作用域一次对话。 或者可以说：在JSESSIONID和Session对象不失效的情况下，它的作用域为整个项目。 重点用户什么时候能获取到Session？ 什么时候会获取到新的Session？ Session什么时候失效？ Session的数据流转和总结存储和获取数据1234// 存储session.setAttribute(String name, Object value);// 获取session.getAttribute(String name); // 返回的数据类型为Object 注意：存储的动作和取出的动作发生在不同请求中，但是存储要先于取出。 Session的使用时机一般用户在登录web项目时会将个人信息存储到Session中，供该用户的其他请求使用。 总结Session解决了一个用户在不同请求的数据共享问题，只要JSESSIONID不失效和Session对象不失效的情况下，用户的任意请求在处理时都能获取到同一个Session对象。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb05-Cookie]]></title>
    <url>%2F2019%2F01%2F17%2FJavaWeb05-Cookie%2F</url>
    <content type="text"><![CDATA[Cookie介绍及使用（创建和设置有效期）Cookie的作用解决了发送的不同请求之间的数据共享问题。 注意 Cookie不能存中文。要我Cookie封装在响应头和请求行里，HTTP响应头和请求行中不能有中文。 Cookie不安全。 一个Cookie对象存储一条数据，多条数据需要多创建几个Cookie对象进行存储。 使用Cookie的创建和存储 123456789// 创建Cookie对象Cookie cookie = new Cookie(String cookieName, String value);// 设置Cookiecookie.setMaxAge(int expiry); // 设置Cookie存储时间（注：expiry单位为秒）cookie.setPath(String uri); // 设置Cookir的请求路径// 响应Cookie对象给客户端response.addCookie(Cookie cookie); Cookie的获取 1234567// 获取Cookie信息数组Cookie[] cookies = response.getCookies();// 遍历Cookie信息数组（使用for循环遍历即可）for (Cookie ck : cookies) &#123; String name = ck.getName(); String value = ck.getValie();&#125; 特点 Cookie是浏览器端的数据存储技术； 存储的数据声明在服务器端； 临时存储：存储在浏览器的运行内存中，浏览器关闭即失效； 定时存储：设置了Cookie的有效期，存储在客户端的硬盘中，在有效期内，符合路径要求的都会附带该信息； 默认Cookie信息存储好之后，每次请求都会附带，除非设置请求路径。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb04-请求转发、重定向]]></title>
    <url>%2F2019%2F01%2F15%2FJavaWeb04-%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E3%80%81%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[请求乱码问题解决 使用String进行重新编码 1String name = new String(req.getParameter(“name”).toBytes(“iso8859-1”),”utf-8”); 使用公共配置 Get请求方式：第一步：在service()方法中使用req.setCharacterEncoding(“utf-8”);第二步：在tomcat服务器目录下的conf文件夹下找到server.xml文件，打开进行如下配置： 1&lt;Connector port=”8080” protocol=”HTTP/1.1” connectorTimeout=”20000” redirectPort=”8443” useBodyEncodingForURI=”true”/&gt; Post请求方式：在service()方法中使用request.setCharacterEncoding(“utf-8”); Servlet流程总结未加粗文本为不可见的，由Servlet容器或浏览器完成。 加粗文本为开发人员控制的，开发时需要关注的内容，Servlet的使用流程。 浏览器发起请求到服务器（请求）服务器接收浏览器的请求进行解析，创建request对象存储请求数据服务器调用对应的Servlet进行请求处理，并将request对象作为实参传递给Servlet的方法Servlet的方法执行进行请求处理 设置请求编码格式 设置响应编码格式 获取请求信息 处理请求信息 创建业务层对象 处理 调用业务层对象方法 响应处理结果 数据流程流程浏览器—-&gt;服务器—-&gt;数据库浏览器&lt;—-服务器&lt;—-数据库 请求转发问题服务器在接收到浏览器的请求后，仅仅使用一个Servlet进行请求处理，会造成不同的Servlet进行请求处理，会造成不同的Servlet逻辑代码冗余，Servlet的职责不明确。 解决使用请求转发。 特点 一次请求； 地址栏地址不改变。 作用实现多个Servlet联动操作处理请求，这样避免代码冗余，让Servlet的职责更加明确。 使用1req.getRequestDispatcher(“要转发的地址”).forward(req, response); 要转发的地址：相对路径。可以是Servlet的url-pattern地址，也可以是jsp文件位置。 注意请求转发后直接return即可。因为请求转发之后转发到的servlet进行处理之后已经对请求做出响应，做出请求转发操作的servlet再继续进行操作也没有意义了。 联想语句：多个Servlet联动处理同一个请求。 request对象的作用域问题假如第一个Servlet需要将处理结果或者处理建议给到第二个Servlet，使用请求转发后，不同Servlet之间怎么进行数据的共享呢？或者说数据怎么从一个Servlet流转到另一个Servlet呢？ 提醒：前一个Servlet将处理结果封装到request对象中，后一个Servlet将前一个Servlet封装的信息取出来并删除(看情况而定)，进行处理之后再进行同样的步骤转发给后面的Servlet（如果有）。 使用1234// 封装数据req.setAttribute(String name, Object obj);// 获取数据req.getAttribute(String name); 作用解决了一次请求内的不同Servlet的数据（请求数据+其他数据）共享问题。 作用域基于请求转发，一次请求中的所有Servlet共享。（或者说：一次请求内，请求所经历的所有servlet共享同一个request）。 注意使用request对象进行数据流转，数据只在一次请求内有效。 特点 Request由服务器创建 每次请求都会创建 生命周期：一次请求内 重定向问题 如果当前的请求，Servlet无法进行处理怎么办？ 如果使用请求转发，造成表单数据重复提交，怎么办？ 解决使用重定向。 使用123response.sendRedirect(“路径”);本地路径为：uri网络路径为：定向资源的URL信息 特点 两次请求 浏览器地址改变 避免表单重复提交 使用场景 如果请求中有表单数据，而数据又比较重要，不能重复提交，建议使用重定向。 如果请求被Servlet接收后，无法进行处理，建议使用重定向定位到可以处理的资源。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb03-Request对象和Response对象]]></title>
    <url>%2F2019%2F01%2F13%2FJavaWeb03-Request%E5%AF%B9%E8%B1%A1%E5%92%8CResponse%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Servlet的生命周期 从服务器启动后第一次调用到服务器关闭； 如果Servlet在web.xml中配置了load-on-startup，生命周期为服务器启动到服务器关闭。 从第一次调用，到服务器关闭。如果在web.xml中配置了load-on-startup则是从服务器启动到服务器关闭。 注意init()方法是对Servlet进行初始化的一个方法，会在Servlet第一次加载进入内存时执行。 destroy()方法是在Servlet被销毁时执行，也就是服务器关闭时。 service()方法、doGet()方法以及doPost()方法的使用和区别 service()：不管是get方式还是post方式，如果Servlet类中有service()方法，则优先调用service()方法。但是，不推荐重写service()方法。 doGet()：在没有service()方法的情况下，如果请求方式是get，则调用该处理请求的方法。 doPost()：在没有service()方法的情况下，如果请求方式是post，则调用该处理请求的方法。 注意如果在重写的service()方法中调用了父类的service()方法（super.service(arg0, arg1)），则service方法处理完后，会再次根据请求方式响应doGet()或doPost()方法执行。所以，一般情况下，我们是不在重写的service()方法中调用父类的service()方法的，避免出现405错误。 扩展：常见错误状态码404错误：资源未找到。 原因一：在请求地址中的Servlet别名书写错误。 原因二：虚拟项目名称拼写错误。 500错误：内部服务器错误 错误一：找不到web.xml中配置的url-pattern所映射的servlet类(配置错误，ClassNotFound) 解决：在web.xml中校验servlet类的全限定路径是否拼写错误。 错误二：因为处理请求的方法(service方法\doGet方法\doPost方法)中的代码执行错误导致。 解决：根据错误提示对处理请求的方法体中的代码进行错误排查并更改。 405错误：请求方式不支持 原因：请求方式和servlet中的方法不匹配所导致。解决： 使用service()方法进行请求处理(不推荐)，并不在service()方法中直接使用父类的service()方法 重写doGet()和doPost()方法，并准确根据请求方式进行所重写方法的代码编写 Request对象问题浏览器发起请求到服务器，会遵循HTTP协议将请求数据发送到服务器。那么服务器收到的请求该怎么存储呢？不但要存，而且要保证完整性。 解决使用对象存储，服务器每接收一个请求，就创建一个对象专门存储此次请求数据。 实现Request对象。 解释服务器在接收到浏览器的请求后，会创建一个request对象，对象中存储了此次请求相关的请求数据。服务器在调用Servlet时将创建的request对象作为实参传递给Servlet的方法，比如：service()方法。 作用request对象中封存了当前请求的所有请求信息。 使用获取请求头数据： 12345678// 获取请求方式request.getMethod();// 获取请求URLrequest.getRequestURL();// 获取请求URIrequest.getRequestURI();// 获取请求协议request.getScheme(); 获取请求行数据： 1234// 返回指定的请求头信息request.getHeader("键名");// 返回请求头的枚举集合request.getHeaderNames(); 获取用户数据（核心）： 123456// 获取指定的用户数据request.getParameter("键名");// 返回同键不同值的请求数据(多用于多选按钮)，返回的数组request.getParameterValues("键名");// 返回所有用户请求数据的枚举集合request.getParameterNames(); 注意 如果要获取的请求数据不存在，不会报错，会返回null。 request对象由tomcat服务器创建，并作为实际参数传递给处理请求的servlet的处理请求的方法。 Response对象作用一个用来将数据响应到浏览器的对象。 使用1234567// 设置响应头response.setHeader(String name,String value);// 在响应头中添加信息，但是同键会覆盖。response.addHeader(String name,String value);// 在响应头中添加响应信息，但是不会覆盖。// 设置响应状态response.sendError(int num, String msg);// 自定义响应状态码// 设置响应实体(核心)response.getWriter().write(String str);// 响应具体的数据给浏览器 设置响应编码格式1response.setContentType(“text/html;charset=utf-8”); 总结service()方法请求处理代码流程： 设置响应编码格式 获取请求数据 处理请求数据 数据库操作（MVC思想） 响应处理结果]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[经验分享]保证Cookie自动登录信息安全的方法]]></title>
    <url>%2F2019%2F01%2F12%2F%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB-%E4%BF%9D%E8%AF%81Cookie%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[方法一 将用户的认证信息保存在一个Cookie中。 cookie名：uid。推荐进行加密，比如MD5(‘站点名称’)等。 cookie值：登录名|有效时间|Expires|hash值。hash值可以由“登录名+有效时间Expires+用户密码(进行加密处理后的)的前几位+salt”，salt是保证在服务器端站点配置文件中的随机数。 该设计的缺点 即使数据库被盗了，盗用者还是无法登录到系统，因为组成cookie值的salt是保证在服务器站点配置文件中而非数据库中。 如果账号被盗了，用户修改密码，可以使盗用者的cookie值无效。 如果服务器端的数据库被盗了，通过修改salt值可以使所有用户的cookie值无效，迫使用户重新登录系统。 有效时间Expires可以设置为当前时间+过去时间（比如两天），这样可以保证每次登录的cookie值都不一样，防止盗用者窥探到自己的cookie值后作为后门，长期登录。 方法二每个用户登录之后生成一个随机的GUID，然后把GUID存在数据库里面（也可以考虑使用Redis，把用户信息和随机GUID以KEY-VALUE方式存储GUID-用户信息，存储时设置超时时间，比如20分钟，每次验证用户信息都自动延长20分钟。如果用户选择记住登录，则设置时间为30天）。安全要求高的话，每次重新登录（包括用户名密码和使用GUID）都重新生成GUID，旧的作废，这样在新的地方登录之后旧的记住登录就自动失效。安全要求低的话可以每次都返回相同的，直到用户修改密码之后让旧的GUID作废。用户Cookies里面没有直接和用户名、密码有关的内容，即使Cookies被盗了也无法修改密码，原用户发现账号异常之后只要修改密码就可以防止盗号了。 另：防止XSS攻击，可以将Http-Only设置为True。]]></content>
      <categories>
        <category>实战经验</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb02-Servlet的url-pattern匹配规则]]></title>
    <url>%2F2019%2F01%2F11%2FJavaWeb02-Servlet%E7%9A%84url-pattern%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[几种容易混淆的规则 servlet容器中的匹配规则既不是简单的通配，也不是正则表达式，而是特定的规则。所以不要用通配符或者正则表达式的匹配规则来看到servlet的url-pattern； Servlet 2.5开始，一个servlet可以使用多个url-pattern规则，&lt;servlet-mapping&gt;标签表明了与该servlet响应的匹配规则，每个&lt;url-pattern&amp;gt代表一个匹配规则； 当servlet容器接收到浏览器发起的一个url请求后，容器会用url减去当前应用的上下文路径，以剩下的字符串作为servlet映射，假如url是http://localhost:8080/demo/index.html，其应用上下文是demo，容器http://localhost:8080/demo去掉，用剩下的/index部分拿来做servlet映射匹配； url-pattern映射匹配过程是有优先顺序的，而且，当有一个servlet匹配成功以后，就不会继续往后去匹配后面的servlet了。 一、四种匹配规则精准匹配&lt;url-pattern&gt;中配置的项必须与url完全精准匹配。 123456&lt;servlet-mapping&gt; &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/user/users.html&lt;/url-pattern&gt; &lt;url-pattern&gt;/index.html&lt;/url-pattern&gt; &lt;url-pattern&gt;/user/addUser.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 当在浏览器中输入如下几种url时，都会被匹配到该servlet 123http://localhost:8080/demo/user/user.htmlhttp://localhost:8080/demo/index.htmlhttp://localhost:8080/demo/user/addUser.action 注意：http://localhost:8080/demo/user/addUser/是非法url，不会被当作http://localhost:8080/demo/user/addUser识别 另外，上述url后面可以跟任意的查询条件，都会被匹配，如http://localhost:8080/demo/user/addUser?username=jerry&amp;age=18会被匹配到MyServlet。 路径匹配以”/”字符开头，并以”/*”结尾的字符串用于路径匹配1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/user/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 路径以/user/开始，后面的路径可以任意。比如下面的url都会被匹配： 123http://localhost:8080/demo/user/user.htmlhttp://localhost:8080/demo/user/addUser.actionhttp://localhost:8080/demo/user/updateUser.action 扩展名匹配以”*.”开头的字符串被用于扩展名匹配 12345&lt;servlet-mapping&gt; &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 以上，则任何扩展名为jsp或action的url请求都会匹配，比如下面的url都会被匹配： 12http://localhost:8080/demo/user/users.jsphttp://localhost:8080/demo/toHome.action 缺省匹配1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 二、匹配顺序精准匹配1234servlet-mapping1：&lt;url-pattern&gt;/user/users.html&lt;/url-pattern&gt;servlet-mapping2：&lt;url-pattern&gt;/*&lt;/url-pattern&gt; 当一个请求http://localhost:8080/demo/user/users.hml来的时候，servlet-mapping1匹配到之后不再用servlet-mapping2匹配。 路径匹配先最长路径匹配，再最短路径匹配 1234servlet-mapping1：&lt;url-pattern&gt;/user/*&lt;/url-pattern&gt;servlet-mapping2：&lt;url-pattern&gt;/*&lt;/url-pattern&gt; 当一个请求http://localhost:8080来的时候，servlet-mapping1匹配到之后，不在用servlet-mapping2匹配。 扩展匹配1234servlet-mapping1：&lt;url-pattern&gt;/user/*&lt;/url-pattern&gt;servlet-mapping2：&lt;url-pattern&gt;*.action&lt;/url-pattern&gt; 当一个请求http://localhost:8080/demo/user/addUser.action来的时候，servlet-mapping1匹配到，不再用servlet-mapping2匹配。 缺省匹配以上都找不到servlet，就用默认的servlet，配置为： 1&lt;url-pattern&gt;/&lt;/url-pattern&gt; 三、需要注意的问题路径匹配和扩展名匹配无法同时设置匹配方法只有三种，要么是路径匹配(以”/”字符开头，并以”*”结尾)，要么是扩展名匹配(以”*.”开头)，要么是精确匹配，三种匹配方法不能进行组合，不要想当然使用通配符或正则表达式规则。 如&lt;url-pattern&gt;/user/*.action&lt;/url-pattern&gt;是非法的 另外注意：&lt;url-pattern&gt;/aa/*/bb&lt;/url-pattern&gt;是精准匹配，合法，这里的*不是通配的含义 “/”和”/*”含义不相同 “/*”属于路径匹配，并且可以匹配所有request，由于路径匹配的优先级仅次于精准匹配，所以”/*”会覆盖所有的扩展名匹配，很多404错误均由此引起，所以这是一个特别恶劣的匹配模式，一般只用于filter的url-pattern “/”是servlet中特殊的匹配模式，且该模式有且仅有一个实例，优先级最低，不会覆盖其他任何url-pattern，只是会替换servlet容器的内建default servlet，该模式同样会匹配所有request。 配置”/”后，一种可能的现象是MyServlet会拦截诸如http://localhost:8080/demo/user/addUser.action、http://localhost:8080/demo/user/updateUser的格式的请求，但是并不会拦截http://localhost:8080/demo/user/users.jsp、http://localhost:8080/demo/index.jsp，这是因为servlet容器有内置的”*.jsp”匹配器，而扩展名匹配的优先级高于缺省匹配，所以才会有上述现象。 Tomcat在%CATALINA_HOME%\conf\web.xml文件中配置了默认的servlet，配置代码如下 123456789101112131415161718192021222324252627282930313233343536&lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;fork&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;xpoweredBy&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;3&lt;/load-on-startup&gt; &lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!-- The mappings for the JSP servlet --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 参考文献：http://stackoverflow.com/questions/4140448/difference-between-and-in-servlet-mapping-url-pattern “/”和”/*”均会拦截静态资源的加载，需要特别注意 举例]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Web</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb01-Servlet入门]]></title>
    <url>%2F2019%2F01%2F11%2FJavaWeb01-Servlet%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Servlet概述和介绍概念狭义的Servlet是指Java语言实现的一个接口。广义的Servlet是指任何实现了Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类似的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。 只要是实现了Servlet接口的类都可以称之为Servlet。 Servlet类需要继承HttpServlet，HttpServlet类又继承了GenericServlet类，而GenericServlet类实现了Servlet接口。 特点： 运行在支持Java的应用服务器上； Servlet的实现遵循了服务器能识别的规则，也就是服务器会自动根据请求调用对应的Servlet； 进行请求处理； 简单方便，可移植性强。 Servlet的访问流程运行流程12345URL：http://localhost:8080/myservlet/my组成：服务器地址:端口号/虚拟项目名/servlet的别名注： 虚拟项目：webapps下的文件夹的名称 servlet的别名：在web.xml设置的servlet-name对应的servlet-mapping下的url-pattern 浏览器发送请求到服务器，服务器根据请求URL地址中的URI信息，在Tomcat的webapps目录下找到对应的项目文件夹，然后在web.xml 中检索对应的servlet，找到后调用并执行Servlet。 URI：虚拟项目名/servlet的别名。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Web</tag>
      </tags>
  </entry>
</search>
